Для Задачи 1: Что произойдет, если мы захотим добавить новую сущность "Призрак", который может летать (новый метод Fly()), атаковать, но не имеет здоровья (неуязвим)? Сколько изменений в коде вам потребуется? Опишите шаги.
Добавление "Призрака" потребует изменений только в классе GameEntity и в Main для демонстрации. Шаги:
1.	Добавить флаг bool CanFly в класс GameEntity.
2.	Добавить метод Fly() с проверкой if (CanFly) { Console.WriteLine($"{Name} is flying."); } else { ... }.
3.	В TakeDamage() уже есть проверка на HasHealth, так что для Призрака установить HasHealth = false, и метод просто выведет "has no health".
4.	В Main добавить экземпляр: GameEntity ghost = new GameEntity { Name = "Ghost", Health = 0, CanFly = true, CanAttack = true, CanMove = true, HasHealth = false, CanTalk = false }; и вызвать Fly(), Attack(), Move(), TakeDamage(). Изменений: ~5-10 строк (новый флаг, метод, экземпляр в Main). Код остается в одном месте, но класс становится больше.

Для Задачи 2: Смогли ли вы построить идеальную иерархию без дублирования кода или странных решений (например, CanAttack в базовом классе)? Если нет, с какими проблемами вы столкнулись?
Нет, не смогла построить идеальную иерархию без дублирования. Проблемы:
1.	C# не поддерживает множественное наследование классов, так что Player не может наследовать одновременно от TalkableCharacter (для Talk) и AttackingCharacter (для Attack). Пришлось дублировать метод Attack в классе Player.
2.	Для Zombie нет Name, так что пришлось хардкодить "Zombie" в методах (дублирование логики вывода).
3.	Если поместить Attack в базовый Character, то Loader (наследник TalkableCharacter) получит ненужный Attack, что нарушает требования. Альтернатива - переопределение Attack в Loader для "ничего не делать", но это странное решение (метод есть, но бесполезен).
4.	Общая проблема: "алмаз смерти" не возник, но ветвление приводит к дублированию (Attack в двух местах).

Какой из двух подходов оказался более гибким для описанных в задаче сущностей? Какой более понятным?
Наследование оказалось более гибким, потому что позволяет разделить ответственность (например, Health в Character, Talk в Talkable), и добавление новой сущности может потребовать новый класс без изменения существующих. Однако для этих сущностей гибкость ограничена из-за перекрестных функций (talk + attack для Player, но не для других). Монолитный класс более понятный: вся логика в одном месте, легко увидеть все возможности, нет нужды прослеживать иерархию. Но он менее гибкий для изменений.

Представьте, что проект масштабируется до 50 типов сущностей. Какие проблемы поддержки кода вы foreseen (предвидите) в каждом из подходов?
Для монолитного класса: Класс станет огромным (тысячи строк), с множеством флагов и if-проверок - "эффект домино" при изменениях, трудно читать/поддерживать, высокая связанность, неправильное распределение ответственности (один класс делает все). Добавление новой функции (e.g., Fly) потребует правок в methods для всех сущностей. Для наследования: Глубокая/сложная иерархия приведет к "хрупкому базовому классу" (изменение в GameEntity или Character сломает всех потомков), дублированию кода в ветках, проблемам с добавлением cross-функций (нужно множественное наследование или interfaces, но задача - классы). С 50 сущностями hierarchy станет неочевидной, трудно добавлять/изменять без ломки, возможны "алмазные" конфликты если ввести multiple paths.

